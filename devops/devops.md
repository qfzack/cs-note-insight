## devops和敏捷开发

敏捷开发适用于devops开发流程，可以作为devops的一部分
但是敏捷关注敏捷scrum、看板等实践，devops还会设计CI、CD、CT等流程
敏捷的工作范围仅是敏捷，devops更加关注自动化的实现

## devops是什么，有什么优势

devops是通过自动化工具和流程（CICD）在产品开发的过程中保证开发质量、加速产品的交付速度

## 如何理解基础设施即代码（IaC）

IaC是把基础设施配置如服务器、网络、各种环境，用代码的方式记录下来，并通过自动化工具进行管理，实现配置的自动化、可重复搭建、版本控制、配置可审计

## c/c++的编译

### gcc和go的编译对比

- 编译流程对比

| 阶段       | `gcc`（C语言）                               | `go`（Golang）                              |
|------------|----------------------------------------------|--------------------------------------------|
| 源码文件   | `.c` 文件                                    | `.go` 文件                                  |
| 预处理     | ✅ 使用 cpp 预处理 `#include`, `#define` 等   | ❌ 不需要单独预处理（编译器内部完成）            |
| 编译       | ✅ 转为汇编代码 `.s` 文件                      | ✅ 直接编译为目标代码                        |
| 汇编       | ✅ 汇编为 `.o` 目标文件                        | ✅ 内部处理（不暴露中间步骤）                 |
| 链接       | ✅ 链接为可执行文件 `.out`、`.exe`             | ✅ 直接输出最终可执行文件                     |
| 最终产物   | 原生平台相关的二进制文件（需链接库）               | 原生平台相关的静态可执行文件                   |

- 工具对比

| 对比项            | `gcc`（C语言编译器）                       | `go`（Go编译器）                             |
|-------------------|-----------------------------------------|--------------------------------------------|
| 编译指令          | `gcc main.c -o main`                     | `go build main.go`                         |
| 是否支持链接库     | ✅ 需要手动链接，如 `-lm` 等                | ✅ 默认静态链接，部署简单                     |
| 是否生成中间文件   | ✅ 可生成 `.i`, `.s`, `.o` 等中间产物       | ❌ 不暴露中间产物                            |
| 是否需要运行时     | ❌ 不需要                                 | ❌ 不需要（编译时包含所有依赖）                |
| 交叉编译支持      | ⛔️ 需要依赖交叉工具链                        | ✅ 原生支持交叉编译：`GOOS`, `GOARCH`        |
| 编译速度          | 🚗 相对较慢（多阶段）                       | 🚀 极快（单一编译器处理所有步骤）               |

- 产物&运行方式对比

| 项目            | `gcc`（C）                        | `go`（Golang）                        |
|----------------|-----------------------------------|--------------------------------------|
| 运行产物        | `.out` 或 `.exe` 可执行文件         | 可执行文件（默认静态链接）                |
| 是否平台相关     | ✅ 是（编译时平台绑定）              | ✅ 是（可轻松交叉编译）                  |
| 是否依赖动态库   | 通常依赖 `.so` 或 `.dll`            | 默认全静态编译，不依赖外部库              |
| 可移植性        | 手动编译对应平台版本                  | 支持直接编译为目标平台版本               |

- 底层差异点总结

| 差异点              | `gcc`                                         | `go`                                     |
|--------------------|-----------------------------------------------|------------------------------------------|
| 是否需要手动链接      | ✅ 需要手动链接库、符号处理等                     | ❌ go 编译器自动完成                       |
| 是否有中间产物       | ✅ 多阶段中间产物可见（`.i`、`.s`、`.o`）          | ❌ 不暴露中间产物，黑盒式编译                |
| 是否容易部署         | ⛔️ 依赖动态库，部署需注意环境一致性                 | ✅ 全静态编译，直接拷贝即可运行              |

- 总结

| 编译器  | 特点  |
|--------|------|
| `gcc`  | 传统多阶段编译器，依赖系统库和链接器，部署复杂度较高 |
| `go`   | 内置链接器、静态编译、易部署、编译速度快、支持交叉编译 |

### c/c++的编译流程

因为c/c++是比较早期设计的语言，追求极致的性能和可控性，没有统一的构建模型，编译流程需要把控制权交给开发者，牺牲了简洁换来灵活和高效

完整编译流程：

1. 源代码（.c/.cpp）
   - 预处理器（cpp）
2. 预处理文件（.i）
   - 编译器（cc1）
3. 汇编代码（.s）
   - 汇编器（as）
4. 目标文件（.o）
   - 链接器（ld）
5. 最终可执行程序（a.out/.exe）

设计目的：

- 多模块解耦：各个编译阶段是独立可替换的工具，允许单独调试汇编、替换链接器、使用汇编器优化性能、生成中间文件供后续分析或构建缓存
- 构建系统由开发者负责：c/c++不包含构建机制（像java的jar、go的go.mod），所以要用make、cmake、ninja等外部工具管理依赖关系、增量构建，以及自己组织.h文件、.cpp文件、目标文件.o、库.so/.a

### c/c++编译方式的优点

模块化自由：源码、目标文件、库完全分离

- 分模块编译：每个.c/.cpp文件可以单独编译成.o文件
- 增量编译效率高：修改一个文件，只需要重编一个目标文件，提升大项目构建的速度
- 可复用的库机制：编译好的.a（静态库）或.so（动态库）可以在多个项目中复用
- 多语言链接灵活：c/c++项目可以和汇编、Rust、Fortran等语言混合编译，只要ABI一致

对构建过程的完全控制权

- 如何链接（静态或动态）
- 哪些符号暴露（通过nm，objdump分析）
- 编译优化等级（-02，-03，-0s）
- 是否启用调试信息（-g）
- 自定义编译器/汇编器/链接器参数
- 手动控制内存布局、段、函数对齐等底层细节

编译优化空间大

- 编译器优化：如-02，-03，-march=native等针对指令集优化
- 手动内联汇编：提高关键路径性能
- 链接时优化（LTO）：编译期和链接期协作做跨模块优化
- 自定义内存布局：为性能/空间定制更合适的分布方式

构建系统和工具链可替换

- 可以使用make、cmake、bazel、ninja、qmake等
- 可以替换为其他编译器（如Clang、Intel ICC）
- 链接器可以用GNU Id、Gold、LLD等
- 易于深度集成到操作系统或大平台构建流程中

容易调试、分析、集成底层工具

- 用gdb或lldb精确调试机器级别的行为
- 用valgrind、perf分析内存/CPU性能
- 查看二进制结构（readelf、objdump、nm）
- 控制对齐、节（section）、符号表、链接脚本等

最终可移植到任何平台

- 编译得到的.o或.exe是平台原生格式
- 几乎可以在任何系统运行

### gcc和cmake

gcc是编译器，cmake是构建系统生成工具

gcc是c/c++的编译器，是底层执行者：

- 编译源代码.c/.cpp到.o目标文件
- 链接目标文件到可执行文件或库
- 可以直接使用命令行编译小程序

cmake是构建系统生成器，是上层组织者：

- 可以自动生成构建脚本（如makefile或ninja）
- 管理项目依赖关系（多个源文件/模块/库）
- 跨平台构建（windows/linux/macOS都支持）
- 让你不用手写gcc命令

## DevOps的CD策略

### 蓝绿发布（Blue-Green Deployment）

核心逻辑是准备两套完全相同的环境，一套是当前线上运行的环境（蓝色），另一套是新版本部署的环境（绿色），通过切换路由（如负载均衡器）实现流量的跳转

部署过程为：

1. 当前生产流量全部在蓝色环境运行
2. 在绿色环境部署新版本，并进行全套的功能测试
3. 确认功能没有问题后，将负载均衡器的流量切换到绿色环境
4. 绿色环境变为生产环境，蓝色环境可以保留一段时间作为回滚备用

蓝绿发布的优点是切换速度快，回滚简单，消除了停机时间，但是需要双倍的资源开销，新版本出现问题会影响所有用户

### 金丝雀/灰度发布（Canary Deployment）

金丝雀来源于矿工用金丝雀检测有毒气体，核心思想是现在小范围发布，逐步扩大范围，监控新版本的表现，确保没有问题后再全面推广

部署过程为：

1. 从生产集群中挑选一小部分节点（如5%）部署新版本
2. 将少量真实流量引导至这些节点，观察性能指标和用户反馈
3. 如果没有问题，逐步扩大新版本的覆盖范围（如从5%到20%，再到50%）
4. 最终全量升级，停用旧版本

金丝雀发布的优点是风险极小，能用真实流量验证稳定性，但是缺点在于部署周期较长，需要复杂的监控和流量调度能力

金丝雀发布和A/B测试的区别在于金丝雀发布是为了验证新版本的稳定性和性能，而A/B测试是为了比较和验证两个版本的用户体验和转化率，目标不同

### 滚动发布（Rolling Deployment）

核心逻辑是逐个或者小批量地替换旧版本实例为新版本实例，直到所有节点都更新完

部署过程为：

1. 停用一个旧版本阶段，更新为新版本并启动
2. 检查健康状态
3. 如果健康，继续下一个实例

滚动发布的优点是资源利用率高，也是K8s默认的部署方式，但是缺点是更新过程中可能会有不同版本共存，且回滚的速度较慢
