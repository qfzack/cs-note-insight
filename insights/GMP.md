# GMP

## 进程和线程

常见的解释是：

- **进程（Process）**是操作系统资源分配的最小单位，一个正在运行的程序就是一个进程
- **线程（Thread）**是CPU调度和执行的最小单位，一个进程中可以有多个线程，它们共享进程的资源（内存、文件句柄），但是每个线程有自己的执行栈和寄存器

> CPU执行的最小单位是线程，在单核CPU上，多个线程轮流执行（时间片切换），在多核CPU上，多个线程可以真正并行执行

将进程和线程的概念带入到golang中，实际的golang程序运行的视角来看，当我们通过`go run main.go`启动一个go的程序：

- 操作系统会创建一个进程，来为这个程序分配内存空间（代码段、堆、栈等）
- 默认创建主线程来执行main方法
- 如果在这个程序中又创建了其他线程，那么一个进程中就会出现多个线程同时运行

### 线程的本质

在操作系统里，线程的本质是**被内核管理的执行单元**，线程不是代码，而是一组**运行所需的上下文信息**，操作系统用这些信息来调度和执行线程，一个线程通常包括：

- 程序计数器（PC）
  - 指向线程当前正在执行的指令地址
  - 决定CPU下一条要执行的机器指令
- 寄存器集
  - 保存线程运行过程中用到的中间数据
- 栈（Stack）
  - 每个线程有独立的栈空间，用来存放函数调用记录、本地变量、返回地址
- 线程控制块（TCB，Thread Control Block）
  - 操作系统维护的线程信息，记录了线程ID、状态、优先级、寄存器内容、所属进程ID

线程能够执行程序是因为携带了CPU执行所需的上下文，程序计数器告诉CPU下一条要执行的指令，栈保存调用链，寄存器保存中间结果，操作系统为其分配CPU时间片

### 进程的理解

进程与线程的关系可以理解为：**进程提供资源和环境隔离，是一个资源容器，线程负责实际执行任务**，因此进程的主要作用是：

- 资源分配的基本单位
  - 操作系统以进程为单位来分配和管理资源
  - 内存空间、文件句柄、网络端口、环境变量等都是进程级别的
  - 每个进程都有自己独立的虚拟地址空间、不同的进程之间互不干扰
- 保护和隔离
  - 进程保证一个程序出错不会轻易影响到另一个程序
- 作为执行的容器
  - 线程必须寄生在某个进程中，不能独立存在
  - 进程就像一个容器，里面可以运行多个线程

> 进程本身不执行任务，默认会启动一个主线程来让CPU执行指令

## GMP架构

强大的并发能力是Go的特性之一，而这都依赖于Go的并发调度模型GMP，这也是golang的超越原生协程的关键架构

- **Goroutine**就是常用的协程，一般是用`go`关键字加具体的方法来使用，在调度模型里，一个协程可以被看作是一个任务单元，每个协程有自己的执行栈、状态信息等

- **Machine**可以看作是Go对系统级线程的封装，是真正执行任务（代码）的对象

- **Processor**是调度器，自带一个本地队列（Local Run Queue）用于存放goroutine，Processor的数量决定了同一时间可以执行的goroutine数量，通常与CPU核心数相同（GOMAXPROCS）

GMP里有两种队列：

- LRQ：Processor的本地队列，用于存放待执行的groutine，当M和P绑定之后，会优先从P的本地队列中获取G执行，并且获取的操作不需要加锁，能够提高效率，当本地队列和全局队列空了就会从其他P的队列中获取一半的G（work-stealing机制）

- GRQ：全局共享的存放goroutine的队列，当一个Processor的LRQ满了之后，新创建的G就会放到GRQ里面，因为是全局共享，所以访问需要加锁

### Goroutine

#### goroutine的创建

当Go程序启动时，runtime会自动创建一个主OS线程m0和main goroutine，这是第一个G，也是是执行main方法的goroutine，也就是程序启动时M就创建了，并且会绑定一个P来执行main goroutine

当有新的goroutine被创建：

- 如果创建goroutine的线程有绑定的P，就会把创建的G放到P的LRQ的末尾，如果LRQ满了就会加锁放到GRQ

每个M都有自己的g0，是在runtime初始化M的时候创建的特殊的G，g0的工作就是不断地调用schedule来寻找可真行的G，所以M的生命周期中就是在执行g0和普通G之间来回切换

#### goroutine的消费

当P绑定了M之后，M会获取P的LRQ上的goroutine执行：

- 先从当前P的LRQ里获取goroutine，这个操作不加锁，速度快

- 如果LRQ没有goroutine了，就去全局的GRQ里获取，需要加锁

- 如果GRQ里也没有，就去网络轮询器（netpoll）里找有没有因为IO操作阻塞的goroutine

- 如果还是没有就会执行work stealing（队列窃取），从其他P的LRQ窃取一半的G来执行，也是无锁的

- 再次检查GRQ和netpoll，如果还是没有任务执行则M进入休眠，交出线程的控制权

> 因为goroutine是优先从LRQ获取的，为了防止GRQ里的G饥饿，调度器每进行61次循环都会强制下一次去GRQ获取

### Machine

#### machine的创建

machine的数量一般是多于P的数量，并且machine是按需创建的，M的创建有以下几种情况：

1. 程序启动时

golang程序启动时，会创建一个主machine，并绑定一个processor

2. 当前M的数量不够

如果当前的M不够执行LRQ和GRQ里的G，调度器会创建新的M来绑定P处理更多的G，但是通常会有上限

3. 系统调用阻塞

当G调用cgo或者其他阻塞系统如read/write/accept的调用，M会被阻塞在syscall里，调度器会创建新的M来执行G

M不是永久存在的，阻塞接解除之后多余的M会被回收，runtime会维护一个M池，减少线程创建和销毁的开销

### Processor

每个P上除了LRQ外还有一个私有的内存缓存mcache，当一个P上的G需要分配小对象时，可以直接从这个mcache里获取，并且是无锁操作

### GMP的阻塞

系统中一些阻塞的情况会导致任务无法继续执行或者要等待，长时间的阻塞对于高并发的场景是不能接收的，在GMP中的阻塞可能是G或者M的阻塞：

1. goroutine的阻塞（用户态）

goroutine阻塞会导致G被挂起，M可以继续执行后面的G，常见的情况有：channel阻塞、sync包的锁阻塞、time.Sleep等操作，G的阻塞不会占用OS线程的资源

当G的调用阻塞（如ch <- x），调度器会标记G为阻塞状态，G的状态标记为Gwaiting，M检查P的LRQ或者GRQ上是否有其他G可以执行，如果没有G执行则进入空闲状态或者被其他P绑定

当阻塞条件解除，对应的G会被重新放回P的LRQ继续调度，整个过程是在用户态完成的，可以极大地提升并发性能

> golang采用linux的epoll，为了避免epoll的等待操作阻塞整个M，设计了netpoll机制，将IO阻塞转换成了G级别的阻塞（gopark），当IO就绪再通过goready唤醒对应的G

2. machine的阻塞（内核态）

machine阻塞会导致整个线程无法继续执行其他的G，此时调度器需要创建新的M继续执行G，常见的情况有：系统调用阻塞（I/O）、cgo调用阻塞、内核等待（select/poll），M的挂起会占用OS线程的资源

## 常见问题

- 一个goroutine从执行阻塞到恢复调度经历了什么
