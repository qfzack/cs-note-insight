- 关系型数据库
  - MySQL/PostgreSQL：SQL优化、事务处理、连接池
  - ORM框架：Gorm、Ent、SQLx
  - 数据库设计：表结构设计、索引优化、分库分表
- NoSQL数据库
  - Redis：缓存策略、分布式锁、数据结构
  - MongoDB：文档数据库操作、聚合查询
  - Elasticsearch：搜索引擎、日志分析

---

## Redis

### 基本数据类型

String(字符串)
- 可以是字符串、整数或者浮点数
- 用于缓存对象、常规计数、分布式锁、共享session信息
Hash（哈希）
- 包含键值对的无序散列表
- 用于缓存对象、购物
List（列表）
- 一个链表，链表上每个节点包含一个字符串
- 用于消息队列
Set（集合）
- 字符串的无序集合
- 用于聚合计算（并集、交集、差集），比如点赞、共同关注
Zset（有序集合）
- 有序的集合
- 用于排序场景，如排行榜、姓名排序

Bitmaps（位图）
- 二值状态统计，比如签到、判断登陆状态
HyperLogLog（基数统计）
- 海量数据基数的统计
GEO（地理信息）
- 存储地理位置信息
Stream（流）
- 消息队列，相比于list可以自动生成唯一ID，支持消费组进行数据消费

（各类型底层实现原理）

对数据的操作都是原子性的，不存在并发竞争问题

支持事务、持久化、Lua脚本、多种集群方案（主从复制、哨兵、切片集群）、发布订阅、内存淘汰、过期删除

### 线程模型

单线程：接收客户端请求、解析请求、进行数据读写、发送数据给客户端等都是由一个线程完成的

Redis的瓶颈在于机器的网络IO和内存，而不是CPU，单线程IO多路复用可以避免多线程竞争和提高请求处理能力

如果想充分发挥CPU多核能力，可以部署多个Redis节点采用分片或者读写分离

但是会启动多个线程，其他的用于关闭文件、AOF刷盘、释放内存（各自有任务队列），避免主线程阻塞

> 为什么单线程Redis可以做到数万的QPS https://mp.weixin.qq.com/s/oeOfsgF-9IOoT5eQt5ieyw

6.0开始引入多个线程，但是命令的执行还是单线程，网络读写和解析/序列化可以多线程

### 持久化

AOF日志（Append Only File）
- 每次执行一个命令都追加写入到一个磁盘文件中（先执行再写日志），恢复数据时逐一执行命令
- 服务器宕机可能导致执行成功但日志写入失败，从而数据丢失
- 写日志也是主线程执行的，会阻塞后续操作
- 日志是先追加到缓冲区，然后再写入AOF文件，有三种策略：Always（每次操作都把缓冲区日志写到硬盘）、Everysec（每秒把缓冲区写到硬盘）、No（操作系统决定何时把缓冲区写到硬盘）
- AOF重写机制：为了避免AOF文件持续增大，当大小超过阈值会读取所有键值对，每个用一条命令记录到新的AOF文件然后替换（后台子进程完成），重写缓冲区和AOF缓冲区一起用

RDB快照（Redis Database Snapshot）
- 将某一时刻的内存数据（实际数据而不是执行的命令），以二进制的方式写入磁盘，数据恢复效率比AOF快
- save命令（主线程）和bgsave命令（子进程，写时复制Copy-On-Write，COW）

混合持久化
- 开启之后，AOF重写日志时，fork的子进程会先将主线程共享的内存数据以RDB方式写入AOF文件，然后主线程的操作记录在重写缓冲区，以AOF形式写入AOF文件
- 混合持久化的AOF文件前面是RDB格式的全量数据，后面是AOF格式的增量数据

### 高可用

主从复制
- 读写分离，一主多从，主服务器读写，写操作同步到从服务器，从服务器只读
- 主服务器操作同步到从服务器是异步的，无法保证从服务器执行成功，因此无法保证强一致性

哨兵模式
- 可以监控主从服务器，并提供主从节点的故障转移功能

切片集群
- 将数据分布到不同的服务器上，提高服务的读写性能
- 一个切片集群有16384个哈希槽，每个键值对会映射到一个槽，创建集群的时候会均匀分配槽位，或者手动分配

集群脑裂

### 过期删除和内存淘汰

对key设置了过期时间时，会把key存储到一个过期词典中，读取key时会判断是否过期

惰性删除+定期删除：不主动删除过期key，访问到的时候如果过期则删除，定期也会取出一定量的key，删除其中过期的key

RDB文件生成的时候，会对key进行过期检查，过期的key不会保存到RDB文件中，主服务器加载的时候也不会加载过期的key

AOF文件中如果key过期删除会追加删除的命令，AOF重写的时候会检查过期的key不会写到新的AOF文件中

Redis内存到达阈值后会触发内存淘汰：
1. noeviction：（默认）不淘汰数据，返回报错
2. volatile-random：随机淘汰设置过期时间的数据
3. volatile-ttl：优先淘汰设置过期时间中快要过期的数据
4. volatile-lru：淘汰设置过期时间中最久未使用的数据
5. volatile-lfr：淘汰设置过期时间中最少使用的数据
6. allkeys-random：随机淘汰任意数据
7. allkeys-lru：淘汰最久没使用的数据
8. allkeys-lfu：淘汰最少使用的数据

### 缓存设计

缓存雪崩
- 大量缓存数据同一时间过期，此时如果有大量请求，会导致数据库压力过大
- 解决方案：缓存实效时间打散、设置缓存不过期

缓存击穿
- 热点数据过期，导致大量请求直接访问数据库
- 解决方案：互斥锁保证及时重建缓存、设置热点数据不过期

缓存穿透
- 请求的数据不在缓存中，也不在数据库中（数据被误删）
- 解决方案：限制非法请求、设置空返回值或默认值、使用布隆过滤器快速判断数据是否存在

### 大key的处理

大key是string的值大于10KB，或者hash、list、set、zset类型的元素个数超过5000个

大key会导致客户端超时阻塞、网络阻塞、阻塞工作线程、内存分布不均匀

查找大key：redis-cli --bigkeys、使用SCAN命令扫描、使用RdbTools

删除大key：要分批次或异步删除

### 管道

是为了解决多个命令执行时的网络等待，把多个命令整合到一起发送到服务器端处理之后统一返回给客户端

### 事务回滚

redis事务不支持回滚，即不保证事务的原子性

### 分布式锁

redis可以作为一个共享存储系统被多个客户端共享，可以用来保证分布式锁

SET命令的NX参数是key不存在时才插入，因此：
- 当key不存在，显示插入成功，表示加锁成功
- 当key存在，显示插入失败，表示加锁失败

加锁需要通过EX/PX参数设置过期时间，而解锁的过程就是把key删除