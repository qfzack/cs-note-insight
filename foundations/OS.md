# 硬件结构

## 软中断

**中断**是计算机系统用来响应硬件设备请求的一种机制，操作系统收到中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求

中断是一种异步的事件处理机制，可以提供系统的并发处理能力

Linux系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分为两个阶段：

- 上半部是硬中断，用来快速处理中断
- 下半部是软中断，用来延迟处理上半部未完成的工作

Linux的软中断包括网络收发、定时、调度、RCU锁等类型，可以通过/proc/softirqs来观察软中断的累积中断次数

每个CPU核心都有各自的软中断内核线程

## 计算机存储小数

计算机对于整数的存储是使用二进制，最高位是符号位，剩余位置用于表示二进制数，对于负数符号位是1，剩余位置是补码表示

对于小数，转换为二进制的方法是乘2取整法，例如0.625转换为二进制就是.101

而对于0.1，转换为二进制就是0.00011001100110011...无限循环，所以0.1是无法用完整的二进制表示的，只能以近似数的方式来保存

计算机中能够精确表示的小数是可以被2除尽的数字

因此计算机中0.1+0.2并不完整等于0.3

# 操作系统结构

## 内核

内核是连接应用程序与硬件设备的桥梁，应用程序只需要与内核交互，不用关心硬件的细节

内核的能力：

- 管理进程、线程，决定哪个进程、线程使用CPU，也就是进程调度的能力
- 管理内存，决定内存的分配和回收，也就是内存管理的能力
- 管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力
- 提供系统调用，如果应用程序要更高权限来运行服务，就需要系统调用，它是用户程序与操作系统之间的接口

大多数操作系统会把内存分为：

- 内核空间，只有内核程序可以访问
- 用户空间，专门给应用程序使用

用户空间的代码只能访问一个局部的内存空间，也就是用户态执行，而内核空间的代码可以访问所有内存空间，也就是内核态执行

## Linux设计

Linux内核设计理念：

- MultiTask，多任务，可以有多个任务并发或并行运行
- SMP，对称多处理，每个CPU的地位都是相等的，每个程序都可以被分配到任意一个CPU上执行
- ELF，可执行文件链接格式，可执行文件的存储格式
- Monolithic Kernel，宏内核，系统内核的所有模块如进程调度、内存管理、文件系统、设备驱动等都在内核态运行，相对应的是微内核，内核只保留基本能力如进程调度、虚拟机内存、中断等，一些应用被放到用户空间如驱动程序、文件系统

# 运行模式

## 用户态和内核态

内核态和用户态是操作系统中的两种运行模式，它们的主要区别在于权限和可执行的操作：

- 内核态（Kernel Mode）：在内核态下，CPU可以执行所有的指令和访问所有的硬件资源，这种模式下的操作有更高的权限，负责进程/线程的调度、内存管理、文件系统、网络协议栈、设备驱动等核心功能
- 用户态（User Mode）：在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源，这种模式下的操作权限较低，主要用于运行用户程序

内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等，这些操作涉及到操作系统的核心功能，需要较高的权限来执行

分为内核态和用户态的原因主要有以下几点：

- 安全性：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏
- 稳定性：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险
- 隔离性：内核态和用户态的划分使得操作系统内核与用户之间有了明确的边界，有利于系统的模块化和维护

总结就是内核态和用户态的划分有助于保证操作系统的安全性、稳定性和易维护性

# 进程管理

## 线程、进程和协程的区别是什么

进程（Process）：

- 进程是一个正在运行的程序实例，是操作系统中进行资源分配的最小单位，拥有独立的内存空间和系统资源
- 进程里包含：独立的地址空间（代码段、堆、栈）、文件描述符、环境变量等
- 进程之间相互隔离，安全性高，因为涉及到内核态，线程创建和切换的成本高

线程（Thread）：

- 线程是操作系统调度执行的最小单位，一个进程可以包含多个线程，多个线程之间共享进程内存，并且各自有独立的栈和寄存器
- 线程比进程更轻量，线程间通信更高效，因为线程共享进程的资源，但是线程之间的隔离性较差，容易引发数据竞争和死锁等问题

协程（Coroutine）：

- 协程是用户态的轻量级线程，由程序自己调度而不是操作系统调度，可以理解为是可被挂起和恢复的函数
- 协程不需要内核态进行切换，因此切换成本低，通常是在程序中控制来协作式调度

| 维度   | 进程    | 线程     | 协程       |
| ---- | ----- | ------ | -------- |
| 调度者  | OS 内核 | OS 内核  | 用户态（运行时） |
| 内存空间 | 独立    | 共享进程内存 | 共享线程内存   |
| 切换成本 | 很高    | 中      | 极低       |
| 创建成本 | 很高    | 中      | 极低       |
| 并行能力 | 真并行   | 真并行    | 依赖线程     |
| 通信方式 | IPC   | 共享内存   | 直接变量     |
| 安全性  | 高     | 中      | 低        |
| 数量级  | 少     | 较多     | 非常多      |

## 为什么进程崩溃不会导致系统崩溃

进程崩溃是因为程序做了非法的事情，比如空指针、野指针、数组越界、访问非法地址、除0等操作

现代操作系统会通过内存隔离+权限隔离+内核保护，把进程的错误掩盖掉：

- 内存隔离：
  - 每个进程都有独立的虚拟地址空间
  - 进程看到的内存地址都是实际物理内存由内核映射的到的
- 用户态/内核态隔离
  - 普通进程运行在用户态，如果出现越界操作会被杀死，不影响内核进程
- 内核保护
  - 系统调用都会检查参数，并且所有内存访问都有边界，从而拒绝错误操作
  - 进程崩溃的时候会回收内存、关闭文件、清理socket

## 进程分配的资源是什么

进程在运行过程中，操作系统为其分配的资源包括：

1. 内存资源
   - 代码段：存放程序的可执行代码
   - 数据段：存放全局变量和静态变量
   - 堆：动态分配内存区域
   - 栈：存放函数调用的局部变量和返回地址
2. CPU时间片：多任务系统的CPU资源是分时复用的，操作系统为每个进程分配的CPU执行时间
3. 文件描述符：进程打开每一个文件、管道或Socket，内核都会分配一个编号进行管理
4. 进程标识
   - PID（Process ID）：系统为每个进程分配的唯一标识符
   - 用户与组ID（UID/GID）：决定了该进程有哪些权限，比如能够读取某个系统文件
5. 通信与同步资源
   - 信号量/锁：用于多个进程或线程之间的协调
   - 消息队列/共享内存：用于进程间的数据交换

## 为什么进程之下还要设计线程

设计线程是为了在保证高效并发的同时，尽可能地降低开销：

1. 降低开销
   - 创建新进程需要操作系统分配独立的内存空间、打开文件句柄、初始化管理数据等，而创建一个线程比创建一个进程快10-100倍，因为线程共享进程的内存空间和资源
   - 并且CPU在进程间切换时，必须刷新缓存并重新加载内存映射，而在同一进程的线程间切换，由于共享内存地址，切换成本更低
2. 共享资源
   - 同一进程下的所有线程共享堆和全局变量，线程间通信更简单高效
   - 一个线程修改了内存中的数据，另一个线程立刻可以看到，便于协同工作，而进程间通信需要IPC机制，开销更大
3. 提高响应速度
   - 多线程可以在一个进程内实现并发处理，比如一个线程处理IO操作，另一个线程处理计算任务，这样可以提高程序的响应速度和资源利用率
4. 资源利用
   - 复杂的计算程序如果只有一个进程一个线程，那么只会跑在一个CPU核心上，其他CPU核的资源无法充分利用
   - 通过多线程机制，操作系统可以将不同线程分发到不同的CPU核上并行运行，提高程序的运行速度

## 多线程对比单线程的优缺点

上面提到的是多线程的优点，其缺点在于：

1. 线程安全与竞态条件：两个线程同时修改同一个变量，如果没有加锁，最终结果可能会出错
2. 死锁：多个线程持有自己的资源不释放并且等待对方的资源，陷入永久等待状态
3. 设计与调度成本高：多线程的问题往往难以复现
4. 资源开销：虽然线程比进程更轻量，但是每个线程仍然需要独立的栈空间和内核管理对象，线程过多会耗尽内存

## 进程切换和线程切换的区别

核心区别在于是否需要切换虚拟内存空间：

- 进程切换
  - 切换也表：操作系统告诉CPU的内存管理单元（MMU）切换到另一个进程的页表
  - 刷新TLB：TLB是CPU内部缓存地址翻译结果的地方，切换进程时需要刷新TLB，清空旧的地址映射，避免访问错误的内存地址
  - 缓存失效：CPU的L1/L2/L3缓存中都是前一个进程的数据，切换到新进程后会有大量的缓存未命中
- 线程切换
  - 同一进程内的线程共享内存地址空间（页表），因此切换开销很小
  - 不换地址空间：线程切换时不需要更改MMU的页表映射，也不需要刷新TLB
  - 只切换上下文：CPU只需要把当前线程的寄存器值（程序计数器、栈指针）保存起来，然后加载新线程的寄存器值即可
  - 缓存命中率高：由于线程共享进程的内存空间，切换后CPU缓存中的数据仍然有效

## 线程切换的过程是什么，上下文怎么保存

线程切换的过程为：

1. 触发切换：线程的CPU时间片用尽，或线程主动放弃CPU（如`yield`或IO阻塞），或更高优先级线程就绪，操作系统内核会触发线程切换
2. 陷入内核态：通过软中断或系统调用，CPU的控制权从用户态转移到操作系统内核
3. 保存当前线程上下文：将CPU寄存器中的实时数据保存到该线程私有的TCB（线程控制块）或其内核栈中，包括：
   - 程序计数器（PC）：指向下一条要执行的指令
   - 栈指针（SP）：指向当前线程的栈顶位置
   - 通用寄存器：保存线程的临时数据
4. 调度决策：操作系统调度器根据调度算法从就绪队列选择下一个要运行的线程
5. 恢复新线程上下文：从新线程的TCB中读取之前保存的数据，重新装填到CPU寄存器中
6. 返回用户态：CPU跳转到新线程上次停下的指令位置（PC寄存器指向的位置）继续执行

上下文其实就是在线程被切走的时候，CPU内部的快照，用于保存线程的运行状态，以便下次恢复时能继续执行，上下文主要保存在两个地方：

- 线程控制块（TCB）：操作系统为每个线程维护的数据结构，保存线程的状态信息，包括寄存器值、堆栈指针、程序计数器等
- 内核栈：每个线程都有自己的内核栈，用于保存函数

保存的信息包括：

- 硬件状态：
  - 程序计数器（PC）：存储下一条要执行的指令地址
  - 栈指针（SP）：指向当前线程的栈顶位置
  - 通用寄存器：保存线程正在进行的计算中间结果
  - 状态寄存器：保存最近一次运算的标识位（是否溢出、是否为0）
- 软件管理信息（TCB中）：
  - 线程ID：唯一标识该线程
  - 线程状态：运行中、就绪还是阻塞
  - 调度优先级：决定下次什么时候能再次轮到
  - 指向所属进程的PCB的指针：因为线程必须共享进程的资源（打开的文件、内存页表等）

## 进程的状态有哪些，怎么切换

## 进程的上下文有哪些

## 进程间通信的方式

## 管道的几种方式

## 信号和信号量的区别

## 共享内存怎么实现

## 线程间通信的方式

## 除了互斥锁还有什么锁

## 进程调度算法有哪些

# 锁

## 为什么并发执行线程要加锁

## 自旋锁是什么，应用在哪些场景

## 死锁发生的条件是什么

## 如何避免死锁

## 银行家算法是什么

## 乐观锁和悲观锁的区别

# 内存管理

## 介绍以下操作系统的内存管理

## 什么是虚拟内存和物理内存

## 什么是页表和段表

## 虚拟地址是怎么转化到物理地址的

## 程序的内存布局是什么样的

## 堆和栈的区别

## fork()会复制哪些东西

## 介绍copy on write（写时复制）

## copy on write节省了什么资源

## malloc 1KB和1MB有什么区别

## 介绍一下brk，mmap

## 操作系统内存不足的时候会发生什么

## 页面置换有哪些算法

# 中断

## 什么是中断

## 中断的流程是什么

## 中断的类型有哪些

## 中断的作用是什么

# 网络I/O

## 了解哪些IO模型

## 服务器处理并发请求有哪几种方式

## 讲一下IO多路复用

## select、poll、epoll的区别

## epoll的边缘触发和水平触发的区别

## redis、nginx、netty是怎么实现高性能的

## 零拷贝是什么
