- 消息中间件
  - Kafka：消息发布与订阅、流处理
  - RabbitMQ：消息队列、任务分发
  - Redis Stream：轻量级流处理
- 异步处理
  - 任务队列：Celery、Machinery
  - 事件驱动架构：事件溯源、CQRS模式

---

## 消息队列

消息队列是一种用于异步通信的组件，生产者把消息放进队列，消费者从队列中取出消息进行处理，即把系统之间的调用，从同步等待变为异步处理

消息队列的作用：

- 解耦：生产者和消费者不直接通信，通过消息队列进行解耦，降低系统间的依赖性
- 削峰填谷：通过消息队列缓冲高峰期的请求，平滑处理流量
- 异步处理：将耗时操作异步化，提高系统响应速度
- 可靠传输：消息队列通常支持持久化，保证消息不丢失、不重复、有序消费
- 广播：消息队列可以实现一对多的消息分发，支持多消费者同时处理同一消息

## 消息队列选型

- Kafka
  - 高吞吐量、天然支持分布式，主要面向日志处理、实时大数据任务，不适合大量单条消息的实时业务（延迟较高）
  - 使用场景：吞吐量第一，延迟不是很敏感，适合大数据场景（日志收集、实时数据分析、大数据处理）
- RabbitMQ
  - 支持AMQP协议，功能丰富，支持复杂路由、事务、确认机制，吞吐量中等
  - 使用场景：需要复杂路由、事务支持、可靠投递、较低延迟的业务场景（订单处理、任务调度、通知系统）
- RocketMQ
  - 支持高吞吐量、低延迟，支持集群和水平扩容，支持延时消息和事务消息，适合java生态
  - 使用场景：需要高吞吐量、低延迟、分布式特性的业务场景（电商交易系统、实时数据处理、大规模消息传递）
- Redis Streams
  - 基于Redis的流数据结构，支持持久化和消费者组，适合轻量级消息队列需求
  - 使用场景：已有Redis部署，轻量级消息队列需求，适合日志收集、简单任务调度、实时数据处理

总结：

- Kafka：高吞吐、日志、大数据
- RabbitMQ：业务系统首选、可靠、路由灵活
- RocketMQ：延时消息、事务消息、金融业务
- Redis Stream：轻量级、高性能、非核心消息

## 避免消息重复消费

生产端为了保证消息发送成功，可能会重复推送，因此重复消息不可避免，必须在消费端处理重复消息的问题

重复发送的原因：

- 消费者处理慢，导致ACK超时，生产者重发
- 消费者处理消息后崩溃，未能发送ACK，生产者重发
- 网络抖动，ACK丢失，生产者重发
- 消费者手动重试

避免重复消费的方法：

- 业务层实现幂等性
  - 设计业务逻辑时，确保多次处理同一消息不会产生副作用
  - 使用业务唯一标识（如订单ID、支付流水号）来判断消息是否已处理
  - 用数据库的唯一索引约束来防止重复插入
- 消息去重缓存
  - 在消费者端维护一个缓存（如Redis、内存HashSet）来记录已处理的消息ID
  - 每次处理消息前，先检查缓存中是否存在（SETNX）该消息ID，存在则跳过处理
  - 适合高性能高并发的场景
- 使用消息队列的去重功能
  - 部分消息队列（如RocketMQ）提供了消息去重功能，可以配置消息ID来实现去重
  - 最终都要结合业务幂等性设计，确保万无一失

常用方案是：Redis缓存+业务幂等性设计+消息唯一ID，既能提高性能，又能保证数据一致性

## 避免消息丢失

消息队列的使用分为三部分：生产者、消息队列、消费者，每个环节都可能导致消息丢失：

- 生产者->MQ
  - 网络异常，消息未发送成功
  - 发送成功但未收到ACK，生产者认为消息发送失败
  - 生产者崩溃但消息未持久化
- MQ存储
  - 消息写入内存但未持久化，服务器宕机导致消息丢失
  - 主从复制延迟，消息未同步到从节点
- MQ->消费者
  - 消费者提前回复ACK，但是消息未处理成功

避免消息丢失的方法：

- 生产者端
  - 开启消息确认机制，确保消息发送成功后再继续
  - 消息表模式，先写入数据库消息表，再发送消息，确保消息不丢失
- 消息队列端
  - 开启消息持久化，确保消息写入磁盘
  - 配置主从复制，确保消息在多个节点间同步
- 消费者端
  - 处理完消息后再发送ACK，确保消息已成功处理

## 保证消息的可靠性和顺序性

- 保证消息可靠性
  - 消息持久化：开启消息队列的持久化功能，确保消息写入磁盘，防止服务器宕机导致消息丢失
  - 消息确认机制：生产者发送消息后等待ACK，消费者处理完消息后再发送ACK，确保消息被成功处理
  - 重试机制：生产者和消费者实现重试机制，处理失败的消息进行重发或重新消费
- 保证消息顺序性
  - 有序消息处理场景识别：明确哪些业务场景需要保证消息顺序性，如订单处理、支付流水等
  - 消息队列对顺序性的支持：部分消息队列本身提供了对顺序性的保证，如Kafka可以通过将消息划分到同一个分区（Partition）来保证消息在分区内是有序的，消费者按照分区读取消息可以保证消息顺序
  - 消费者端顺序处理：消费者在处理消息时，应该避免并发处理导致顺序混乱，可以使用单线程处理或者基于消息的顺序标识进行排序处理
