1. 如何在3000万个数中找出最大的K个数？
使用小根堆（优先队列），维护K个元素遍历所有数，若当前数大于堆顶，则替换堆顶并调整堆最终堆中即为最大K个数
时间复杂度： O(N log K)

2. 如何对一个包含不重复整数的超大文件排序？
采用位图（bitmap）排序每个整数对应bitmap中的一位，读取文件时将对应位设为1，最后遍历bitmap输出所有为1的索引
优化： 对于稀疏分布，可采用分段位图或压缩位图

3. 亿级日志数据如何统计Top10热词？
采用MapReduce思想
Map阶段：分块统计每块的词频TopN
Reduce阶段：合并所有块的TopN，最终得到全局Top10
实现： 可用堆或Trie树辅助统计

4. 如何找出两个50亿URL文件中的相同URL？
哈希分桶：对URL哈希后分到多个小文件，分别在内存中对每个桶去重并找交集
优化： 内存不足时可多次分桶或用外部排序

5. 如何在海量数据中寻找中位数？
采用分治法，从高位到低位统计每一位为0和1的数量，递归缩小范围，最终定位中位数
适用场景： 不能全部加载到内存

6. 秒杀系统如何防止超卖和少卖？
防超卖： 用Redis原子操作扣减库存，Lua脚本保证原子性
防少卖： 扣减库存后异步下单，消息队列失败需重试或持久化补偿
限流： 可用令牌桶或漏桶算法

7. 40亿QQ号如何去重？
使用Bitmap，每个QQ号对应一位，遍历数据将对应位设为1，最后输出所有为1的索引
优化： 分段加载Bitmap，或用布隆过滤器（允许误判）

8. 密码如何安全传输和存储？
传输： 使用HTTPS
存储： 密码+Salt后用慢哈希（如bcrypt、scrypt）加密存储
防爆破： 限制IP或用户输错次数，Redis或数据库记录

9. 推荐系统的召回与排序如何设计？
召回： 聚类、特征相关性筛选出相关视频
排序： 精排模型对召回结果打分排序，推荐TopN

10. 广告系统的架构设计？
前端： 展示广告
后端： 负载均衡、广告投放服务、用户画像服务、广告效果监测
存储： MySQL存用户/广告数据，Redis缓存，Kafka/RabbitMQ异步处理
业务流程： 选择广告、展示、点击处理、效果监测与优化

11. 分布式KV一致性哈希如何实现？
步骤： 节点和Key都哈希到环上，Key顺时针找到第一个节点存储
扩容： 只影响相邻节点数据

### 如何设计幂等性的接口
问题场景：如何防止支付接口重复扣款
解决方案：
- 唯一标识：每个请求携带唯一ID（如订单ID+业务类型）
- 状态记录：数据库使用唯一主键（如订单ID作为主键），插入成功才执行业务逻辑
- 前置检查：处理前先查流水表，若存在记录则直接返回结果

### 分布式锁的实现与选型
关键要求：高可用、可重入、锁失效机制
实现方案对比：
- Redis：高性能、实现简单，但是主从切换可能丢锁，适用高并发短任务
- ZooKeeper：强一致、支持锁阻塞，但是性能低、依赖重，适用强一致场景
- ETCD：基于Raft强一致、低延迟，复杂度较高，适用云原生环境

### GMP模型调度优化
问题场景：海量任务导致Goroutine阻塞，如何提升吞吐量
解决要点：
- 控制并发量：使用work pool限制goroutine的数量，避免调度开销
- 避免阻塞操作：将I/O操作异步化（如结合select和channel）

### Channel应用场景
经典问题：如何使用两个Goroutine交替打印数字和字母
解决方案：
```go
func AlternatePrint() {
    ch1, ch2 := make(chan bool), make(chan bool)
    go func() { // 打印数字
        for i := 1; i <= 26; i++ {
            <-ch1
            fmt.Print(i)
            ch2 <- true
        }
    }()
    go func() { // 打印字母
        for c := 'A'; c <= 'Z'; c++ {
            <-ch2
            fmt.Print(string(c))
            ch1 <- true
        }
    }()
    ch1 <- true // 触发开始
}
```

## 高并发场景设计

### 短链系统设计
核心挑战：海量请求与低延迟
设计要点：
- 发号器：用Redis INCR或Snowflake算法生成唯一ID
- 映射存储：Key-Value数据库（如Redis缓存热数据，HBase持久化）
- 跳转优化：301重定向减轻服务压力

### 定时任务调度器
问题场景：支持百万级任务精准触发
Golang方案：
- 时间轮（TimeWheel）：高效管理任务队列，container/heap实现最小堆
- 分布式协调：ETCD选举Leader节点，避免重复调度

## 数据库与存储设计

### 海量数据查询优化
问题场景：10亿数据中快速查找Top10热门关键词
解决方案：
- 分片统计：按关键词Hash分片到多台机器并行计算
- 堆排序：每台机器维护小根堆（container/heap），合并结果时再全局排序

### 分库分表策略
设计要点：
- 路由键：用户ID作为Sharding Key，避免跨分片查询
- 全局ID：通过Redis或数据库分段生成唯一ID

## 系统设计面试

> https://soulmachine.gitbooks.io/system-design/content/cn/

### 分布式ID生成器

需求：
- 全局唯一：生成的ID往往作为数据库的主键，所以要保证全局唯一，数据库会在这个ID字段上建立聚集索引（Clustered Index），即该字段会影响各条数据在物理存储上的顺序
- 尽可能短：ID要尽可能的简短，节省内存，让数据库索引效率更高，基本上64位整数可以满足绝大多数的场景，如果可以预估ID的最大值就可以使用更少的bit来表示这个ID
- 按照时间粗略有序：查询的时候往往有分页或排序的需求，所以每条数据要添加一个时间字段，并在其上建立普通索引（Secondary Index），如果能让ID按时间粗略有序，则可以省略时间字段，分布式场景下做到精确有序一般性能较差

生成方案
- UUID
  - UUID是一类算法的统称，具体有不同的实现，UUID的特点是每台机器可以独立生成ID，不依赖中心节点，理论上不会重复，所以适合分布式场景，缺点是生成的ID较长，每个ID占用16个字节（可以使用base58、base64编码压缩），并且是无序的，不适合做递增主键
  - 可用于微服务之间唯一标识用户、资源、请求，消息队列的唯一消息ID、日志链路中的trace ID
  - 不适合做数据库自增主键（特别是聚簇索引），可以使用UUID+时间戳（Snowflake）或者有序的UUID
- 多台MySQL服务器
  - MySQL可以产生自增ID，使用多台MySQL服务器，可以组成一个高性能的分布式ID生成器
  - 假设有8个MySQL服务，每个的ID初始值为0到7，且每次递增8，请求随机转发到任一服务中
  - 这样生成的ID不是严格递增的，只是粗略递增
- Snowflake
  - Snowflake是一种用于分布式系统中生成唯一、有序、高性能ID的算法，用于生成分布式环境下全局唯一且趋势递增的ID
  - 一共64位：第一位符号位始终为0，41bits时间戳为毫秒级时间，10bits是节点标识（5位数据中心ID+5位机器ID，最多支持1024个节点），12bits序列号支持每毫秒生成4096个序列号
  - 时间戳靠前保证ID整体有序，机器ID+序列号确保ID唯一性
- Redis自增（INCR）
  - 使用Redis的院子操作INCR/INCRBY实现分布式自增ID，可以保证全局唯一、有序，实现简单、依赖中心Redis服务
  - 缺点是单点故障、性能瓶颈、高可用要求高
> 实际场景可以混合使用，如使用业务前缀+时间戳+随机数

### 短网址系统

需求：
- 分享一个长网址链接，很容易超出140个字数的限制，短网址是把一个长网址链接编程一个短的网址链接，方便在社交媒体上分享

设计方案：
- 短网址的长度：
  - 当前互联网上的网页数量大概是45亿，选小于64位整数的上限，那么使用64位整数可以唯一标识一个网址
  - 大小写字母加数字共62个，可以看作是62进制，7位（假设值）的62进制数足够标识所有网址
- 映射关系
  - 一个长网址可能是在不同的地点、不同用户访问的，这些信息应该记录下来便于进行数据分析
  - 可以将7位的短网址作为唯一ID，ID下记录用户的各种信息，便于后面的数据挖掘工作
- 短网址计算
  - 如果只是计算长网址的哈希，对于哈希冲突的情况不好处理
  - 正确方式是使用分布式发号器（上面的唯一ID生成方式）
- 存储方式
  - 可以将短网址作为key，长网址作为Value进行存储，可以使用传统的关系型数据库（MySQL、PopstgreSQL），也可以使用分布式KV数据库（Redis）
- 重定向
  - 301是永久重定向，302是临时重定向，虽然短网址生成之后不会改变，但是使用301无法统计到短网址被点击的次数，也无法获取到用户的数据，因此要用302临时重定向
- 预防攻击
  - 如果遭遇攻击短时间收到大量请求，会迅速消耗ID
  - 首先可以限制IP的单日请求次数，超出可以拒绝服务
  - 其次可以用一台Redis作为缓存服务，存储的不是短网址：长网址，而是长网址：短网址，并使用LRU机制进行淘汰，如果收到大量同一个长网址的请求，可以直接返回缓存中的短网址而不重新生成

### 任务调度器

需求：
- 实现一个任务调度器，有很多的任务，每个任务有一个时间戳，任务会在该时间点开始执行

实现方案：
- 时间轮：可以理解为一个循环队列
- 假设一个长度为8的时间轮（循环队列），且精度为秒，即每秒走动一格，每格指向一个任务集合，时间轮无限循环
- 每转到一个格子，就扫描格子下面的所有任务，把时间到期的任务取出来执行，新的任务按照执行时间对时间长度取余得到索引位置
- 时间轮的优点是性能高，插入和删除的时间复杂度都是O(1)

### 最近一小时访问频率最高的10个IP

需求：
- 实时输出、从当前时间向前数一个小时、QPS可能达到10w/s

设计方案：
- QPS为10w，那么一小时会有10位*3600个请求
- 可以在内存中创建3600个map放在一个数组/链表中，每秒对应一个map[int32]int32{}，IP的地址为key（int32可以装下所有IPv4地址），出现次数为value，这样一个key-value占用8个字节，一小时总内存是`10w*3600*8字节=2^29*8字节=2^2*2^10*2^10*2^10`=4GB
- 同时创建固定大小为10的小根堆，存放出现次数最大的10个IP，堆顶是10个里面最小的
- 每次来一个请求，先把map对应的计数加一，并检查该IP是否在堆中
  - 如果不在堆中，则把IP在3600个hashMap中的计数器加起来作为总次数，与堆顶的IP次数比较，如果大于堆顶的元素，则替换，否则无操作
  - 如果已经在堆中，则把堆中该IP加一，并更新堆
- 另外需要一个旧的后台进程，每过一秒，把最旧的map销毁（需要更新堆），并为当前一秒的请求创建新的map，从而维持一小时的窗口
